#!/bin/python3

# read json file and generate specific easy-to-read files (currently Markdown)

from typing import List, Set
import argparse, sys, json
from collections import Counter
import numpy as np

def open_or_default(file, mode, default_fd):
    if file is None or file=="" or file=="-":
        return default_fd
    else:
        return open(file, mode)

def printing(s, file):
    print(s, file=file)

class ZObject:
    def __init__(self, d):
        for k,v in d.items():
            setattr(self, k, v)

class MarkdownRender:
    def __init__(self, fd, sep_list: List, show_list: List):
        self.fd = fd
        self.sep_set = set(sep_list)
        self.show_set = set(show_list)
        self.count_entry = 0
        self.count_sep = 0
        #
        self.cached_d = ""

    # todo(note): fixed format
    def _d2str(self, d, keys: Set):
        s = ""
        if "idx" in keys:
            s += f"[#{d.idx}] "
        if "year" in keys:
            s += f"({d.year}) "
        if "proc" in keys:
            s += f"[{d.proc}] "
        if "title" in keys:
            s += f"*{d.title}* "
        if "link" in keys:
            link = d.link
            if not link.startswith("http"):
                link = "https://www.aclweb.org/anthology/" + link
            s += f"[[paper]]({link}), [[bib]]({link}.bib) "
        if "group" in keys:
            s += f"[{d.group}] "
        if "task" in keys:
            s += f"{d.task} "
        if "tag" in keys:
            s += f"{d.tag} "
        return s

    def render_start(self):
        s = f"// auto-generated by *'python3 {' '.join(sys.argv)}'*\n\n"
        self.fd.write(s)

    def render_one(self, d):
        self.count_entry += 1
        sep_str = self._d2str(d, self.sep_set)
        if self.cached_d != sep_str:
            self.count_sep += 1
            self.fd.write("\n### " + sep_str + "\n\n")
            self.cached_d = sep_str
        d_str = self._d2str(d, self.show_set)
        self.fd.write("* " + d_str+"\n")

    def render_end(self):
        s = f"\n\n// auto-generated: NumEntry={self.count_entry}, NumSep={self.count_sep}\n"
        self.fd.write(s)

def init():
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--input", type=str, default="-", metavar='PATH', help='Input data json-file (default stdin).')
    parser.add_argument("-o", "--output", type=str, default="-", metavar='PATH', help='Output md-file (default stdout).')
    parser.add_argument("-e", "--extra", type=str, default="-", metavar='PATH', help='Extra output file (default stderr).')
    # todo(note): here, d means the object for one entry, it will accepts a tmp idx for the filtered ones.
    # step0: filter
    parser.add_argument("--filter", type=str, default="True", help='Filter code, eg.: d.year==2018 and d.proc=="ACL"')
    # step1: count and summary (to extra-output)
    parser.add_argument("--summary", type=str, default="(d.year, d.proc)", help='Summary/Counting code, eg.: (d.year, d.proc).')
    # step2: sort
    parser.add_argument("--sort", type=str, default="(d.year, d.proc)", help='Sorting code, eg.: (d.year, d.idx)')
    # step3: separate / show
    parser.add_argument("--sep", type=str, default="year,proc", help='Fields for separating (sep by ",").')
    parser.add_argument("--show", type=str, default="idx,year,proc,title,link,group,task,tag", help='Fields for showing (sep by ",")')
    a = parser.parse_args()
    a.sep = a.sep.split(",")
    a.show = a.show.split(",")
    return a

def main():
    args = init()
    fin = open_or_default(args.input, "r", sys.stdin)
    fout = open_or_default(args.output, "w", sys.stdout)
    ferr = open_or_default(args.extra, "w", sys.stderr)
    # read json
    data = [ZObject(json.loads(line)) for line in fin]
    printing(f"Read from {fin}, {len(data)} data.", ferr)
    # filter
    ff_filer = compile(args.filter, "", "eval")
    filtered_data = [d for d in data if eval(ff_filer)]
    printing(f"After filtering with {args.filter}, remaining {len(filtered_data)} data.", ferr)
    # summary
    ff_sum = compile(args.summary, "", "eval")
    counts = Counter([eval(ff_sum) for d in filtered_data])
    printing(f"Summary with {args.summary}: {counts.most_common()}", ferr)
    # sort and assign idx
    ff_sort = compile(args.sort, "", "eval")
    to_sort_list = [(eval(ff_sort), d) for d in filtered_data]
    to_sort_list.sort(key=lambda x: x[0])
    for i, d in enumerate(to_sort_list):
        assert not hasattr(d, "idx")
        d[1].idx = i
    # render
    render = MarkdownRender(fout, args.sep, args.show)
    render.render_start()
    for d in to_sort_list:
        render.render_one(d[1])
    render.render_end()
    #
    fin.close()
    fout.close()
    ferr.close()

if __name__ == '__main__':
    main()

# example:
# python3 tools/json2md.py -i .data/data190815.json -o output.md

"""
	# [Default]: list them all
	python3 ../tool/json2md.py -i ../data/data.json -o output.md

	# filter by tag (the ones with tag "train")
	python3 ../tool/json2md.py -i ../data/data.json --filter "'train' in d.tag" -o train.md

	# more complex filters (2016/2017-EMNLP-tag=="train")
	python3 ../tool/json2md.py -i ../data/data.json --filter "'train' in d.tag and (d.year==2016 or d.year==2017) and d.proc=='EMNLP'" -o train2.md

	# sorting and spearating by specific criterions (proc, year)
	python3 ../tool/json2md.py -i ../data/data.json --sort "(d.proc, d.year)" --show "proc,year,title" --sep "proc,year" -o all2.md

	# displaying specific fields (only year,proc,title,link)
	python3 ../tool/json2md.py -i ../data/data.json --show "year,proc,title,link" -o all3.md
"""
